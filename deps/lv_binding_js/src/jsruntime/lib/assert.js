var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (
    a &&
    b &&
    typeof a == "object" &&
    typeof b == "object"
  ) {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0; )
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf && a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (
      a.toString &&
      a.toString !== Object.prototype.toString
    )
      return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;

    for (i = length; i-- !== 0; ) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a !== a && b !== b;
};

class AssertionError extends Error {
  constructor(result) {
    super(result.description);
    this.name = "AssertionError";
    const stack = this.stack
      .split("\n")
      .map((l) => l.trim())
      .filter((l) => l && !/assert.js/.test(l));
    const stackLine = stack[0].replace(/^at/, "").trim();
    this.stack = [
      `at: ${stackLine}`,
      `wanted: ${result.expected}`,
      `found: ${result.actual}`,
      `operator: ${result.operator}`,
    ].join("\n");
  }
}

const assertMethodHook = (fn) =>
  function (...args) {
    const result = fn(...args);
    if (!result.pass) {
      throw new AssertionError(result);
    }
  };
const aliasMethodHook = (methodName) =>
  function (...args) {
    return this[methodName](...args);
  };
const AssertPrototype = {
  equal: assertMethodHook(
    (
      actual,
      expected,
      description = "should be equivalent"
    ) => ({
      pass: fastDeepEqual(actual, expected),
      actual,
      expected,
      description,
      operator: "equal" /* EQUAL */,
    })
  ),
  equals: aliasMethodHook("equal"),
  eq: aliasMethodHook("equal"),
  deepEqual: aliasMethodHook("equal"),
  notEqual: assertMethodHook(
    (
      actual,
      expected,
      description = "should not be equivalent"
    ) => ({
      pass: !fastDeepEqual(actual, expected),
      actual,
      expected,
      description,
      operator: "notEqual" /* NOT_EQUAL */,
    })
  ),
  notEquals: aliasMethodHook("notEqual"),
  notEq: aliasMethodHook("notEqual"),
  notDeepEqual: aliasMethodHook("notEqual"),
  is: assertMethodHook(
    (
      actual,
      expected,
      description = "should be the same"
    ) => ({
      pass: Object.is(actual, expected),
      actual,
      expected,
      description,
      operator: "is" /* IS */,
    })
  ),
  same: aliasMethodHook("is"),
  isNot: assertMethodHook(
    (
      actual,
      expected,
      description = "should not be the same"
    ) => ({
      pass: !Object.is(actual, expected),
      actual,
      expected,
      description,
      operator: "isNot" /* IS_NOT */,
    })
  ),
  notSame: aliasMethodHook("isNot"),
  ok: assertMethodHook(
    (actual, description = "should be truthy") => ({
      pass: Boolean(actual),
      actual,
      expected: "truthy value",
      description,
      operator: "ok" /* OK */,
    })
  ),
  truthy: aliasMethodHook("ok"),
  notOk: assertMethodHook(
    (actual, description = "should be falsy") => ({
      pass: !Boolean(actual),
      actual,
      expected: "falsy value",
      description,
      operator: "notOk" /* NOT_OK */,
    })
  ),
  falsy: aliasMethodHook("notOk"),
  fail: assertMethodHook((description = "fail called") => ({
    pass: false,
    actual: "fail called",
    expected: "fail not called",
    description,
    operator: "fail" /* FAIL */,
  })),
  throws: assertMethodHook(
    (func, expected, description) => {
      let caught;
      let pass;
      let actual;
      if (typeof expected === "string") {
        [expected, description] = [description, expected];
      }
      try {
        func();
      } catch (err) {
        caught = { error: err };
      }
      pass = caught !== undefined;
      actual = caught && caught.error;
      if (expected instanceof RegExp) {
        pass =
          expected.test(actual) ||
          expected.test(actual && actual.message);
        actual = (actual && actual.message) || actual;
        expected = String(expected);
      } else if (typeof expected === "function" && caught) {
        pass = actual instanceof expected;
        actual = actual.constructor;
      }
      return {
        pass,
        actual,
        expected,
        description: description || "should throw",
        operator: "throws" /* THROWS */,
      };
    }
  ),
  doesNotThrow: assertMethodHook(
    (func, expected, description) => {
      let caught;
      if (typeof expected === "string") {
        [expected, description] = [description, expected];
      }
      try {
        func();
      } catch (err) {
        caught = { error: err };
      }
      return {
        pass: caught === undefined,
        expected: "no thrown error",
        actual: caught && caught.error,
        operator: "doesNotThrow" /* DOES_NOT_THROW */,
        description: description || "should not throw",
      };
    }
  ),
};

module.exports = Object.create(AssertPrototype);
