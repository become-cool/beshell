{
    "hpp":
    {
      "prefix": "hpp",
      "description": "hpp",
      "body":
      [
        "#pragma once",
        "",
        "namespace be {",
        "    class ${TM_FILENAME_BASE} {",
        "    private:",
        "    public:",
        "        ${TM_FILENAME_BASE}() ;",
        "    } ;",
        "}"
      ]
    },
    "cpp":
    {
      "prefix": "cpp",
      "description": "cpp",
      "body":
      [
        "#include \"${TM_FILENAME_BASE}.hpp\"",
        "using namespace std;",
        "",
        "",
        "namespace be {",
        "    ${TM_FILENAME_BASE}::${TM_FILENAME_BASE}() {",
        "",
        "    }",
        "}"
      ]
    },
    "hppmodule":
    {
      "prefix": "hppmodule",
      "description": "bemodule hpp",
      "body":
      [
        "#pragma once",
        "#include \"module/NativeModule.hpp\"",
        "",
        "namespace be {",
        "    class ${TM_FILENAME_BASE}: public NativeModule {",
        "    private:",
        "    public:",
        "        ${TM_FILENAME_BASE}() ;",
        "        ",
        "        static JSValue jsMethod(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) ;",
        "    } ;",
        "}"
      ]
    },
    "cppmodule":
    {
      "prefix": "cppmodule",
      "description": "cppmodule",
      "body":
      [
        "#include \"module/${TM_FILENAME_BASE}.hpp\"",
        "",
        "using namespace std ;",
        "",
        "namespace be {",
        "    ${TM_FILENAME_BASE}::${TM_FILENAME_BASE}(): NativeModule(\"${TM_FILENAME_BASE}\") {",
        "        isGlobal = false ;",
        "        isReplGlobal = false ;",
        "",
        "        exportFunction(\"method\",jsMethod) ;",
        "    }",
        "    ",
        "    JSValue ${TM_FILENAME_BASE}::jsMethod(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {",
        "        return JS_UNDEFINED ;",
        "    }",
        "}"
      ]
    },
    
    "nclass-hpp":
    {
        "prefix": "nclasshpp",
        "description": "BeShell Native Class header file (.hpp)",
        "body":
        [
            "#pragma once" ,
            "" ,
            "#include <NativeClass.hpp>" ,
            "" ,
            "class ${TM_FILENAME_BASE}: public be::NativeClass<${TM_FILENAME_BASE}> {" ,
            "  DECLARE_NCLASS_META" ,
            "  static std::vector<JSCFunctionListEntry> methods ;" ,
            "  // static std::vector<JSCFunctionListEntry> staticMethods ;" ,
            "" ,
            "public:",
            "    ${TM_FILENAME_BASE}(JSContext * ctx) ;" ,
            "" ,
            "    static JSValue jsMethod(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) ;" ,
            "" ,
            "} ;" ,
        ]
    },

    
    "nclass-cpp":
    {
        "prefix": "nclasscpp",
        "description": "BeShell Native Class source file (.cpp)",
        "body":
        [
            "#include \"${TM_FILENAME_BASE}.hpp\"",
            "" ,
            "using namespace std ;",
            "" ,
            "DEFINE_NCLASS_META(${TM_FILENAME_BASE})",
            "std::vector<JSCFunctionListEntry> ${TM_FILENAME_BASE}::methods = {",
            "    JS_CFUNC_DEF(\"method\", 0, ${TM_FILENAME_BASE}::jsMethod),",
            "} ;",
            "" ,
            "${TM_FILENAME_BASE}::${TM_FILENAME_BASE}(JSContext * ctx)",
            "    : NativeClass(ctx)",
            "{",
            "}",
            "" ,
            "JSValue ${TM_FILENAME_BASE}::jsMethod(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {",
            "    return JS_UNDEFINED ;",
            "}",
        ]
    }

    , "nmodule-hpp":
    {
        "prefix": "nmodulehpp",
        "description": "BeShell Native Module header file (.hpp)",
        "body":
        [
            "#pragma once" ,
            "" ,
            "#include \"BeShell.hpp\"" ,
            "#include \"NativeModule.hpp\"" ,
            "" ,
            "class ${TM_FILENAME_BASE}: public be::NativeModule {" ,
            "public:" ,
            "    ${TM_FILENAME_BASE}(JSContext * ctx, const char * name) ;" ,
            "" ,
            "    \/\/ void import() ;" ,
            "" ,
            "    static void use(be::BeShell & beshell) ;" ,
            "" ,
            "    static JSValue jsFunc(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) ;" ,
            "} ;" ,
            ""
        ]
    }
    
    , "nmodule-cpp":
    {
        "prefix": "nmodulecpp",
        "description": "BeShell Native Module source file (.cpp)",
        "body":
        [
            "#include \"${TM_FILENAME_BASE}.hpp\"" ,
            "" ,
            "${TM_FILENAME_BASE}::${TM_FILENAME_BASE}(JSContext * ctx, const char * name)",
            "    : NativeModule(ctx, name, 0)",
            "{",
            "    \/\/ exportClass<ClassName>() ;",
            "    exportFunction(\"func\",jsFunc,0) ;",
            "}",
            "" ,
            "\/\/ void ${TM_FILENAME_BASE}::import() {",
            "\/\/ }",
            "" ,
            "void ${TM_FILENAME_BASE}::use(be::BeShell & beshell) {",
            "    beshell.addModule<${TM_FILENAME_BASE}>(\"${TM_FILENAME_BASE/(.+)/${1:/downcase}/g}\") ;",
            "}" ,
            "" ,
            "JSValue ${TM_FILENAME_BASE}::jsFunc(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv) {" ,
            "    return JS_UNDEFINED ;" ,
            "}" ,
            ""
        ]
    }
  }